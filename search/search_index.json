{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Quick Start \u00b6 grappler provides a way to load plugins into Python 3.8+ applications. Plugins are third party code that provide a function that your application needs. With grappler, you can easily iterate through plugins by topic and seamlessly filter by object types that your program is able to handle. Usage \u00b6 grappler provides a Hook interface which can be used to specific a topic to iterate plugin objects: from abc import ABC , abstractmethod from grappler import Hook class Surface ( ABC ): @abstractmethod def paint ( self , context : dict [ str , int ]) -> None : \"\"\"Paint onto the surface with the given context.\"\"\" hook = Hook [ Surface ]( topic = \"your.app.topics.surface\" ) for surface in hook : surface . paint ({ ... }) grappler supports type hints, and the surface objects returned from the hook above will be hinted as Surface instances. You can furthermore load any type of object you want from an plugin. To do this, don't provide any type hint to the constructor (or use Any ): hook = Hook ( \"your.app.topics.printables\" ) for obj in hook : print ( f \"Loaded object of type: { type ( obj ) } \" )","title":"Quick Start"},{"location":"#quick-start","text":"grappler provides a way to load plugins into Python 3.8+ applications. Plugins are third party code that provide a function that your application needs. With grappler, you can easily iterate through plugins by topic and seamlessly filter by object types that your program is able to handle.","title":"Quick Start"},{"location":"#usage","text":"grappler provides a Hook interface which can be used to specific a topic to iterate plugin objects: from abc import ABC , abstractmethod from grappler import Hook class Surface ( ABC ): @abstractmethod def paint ( self , context : dict [ str , int ]) -> None : \"\"\"Paint onto the surface with the given context.\"\"\" hook = Hook [ Surface ]( topic = \"your.app.topics.surface\" ) for surface in hook : surface . paint ({ ... }) grappler supports type hints, and the surface objects returned from the hook above will be hinted as Surface instances. You can furthermore load any type of object you want from an plugin. To do this, don't provide any type hint to the constructor (or use Any ): hook = Hook ( \"your.app.topics.printables\" ) for obj in hook : print ( f \"Loaded object of type: { type ( obj ) } \" )","title":"Usage"},{"location":"user-guide/","text":"User Guide \u00b6 Grappler's purpose is to provide a simple interface that you can use to load \"plugins\" into your Python application. In its default configuration, it allows you to load objects from third-party code that has been installed into the same environment as your application. This page explores how to use grappler to load plugins from third-party code. Furthermore, it will examine how to use customise grappler's loading behavior. It assumes knowledge of how to program in Python, including using type annotations, which are required for some mid-advanced features of grappler. Hooks and Topics \u00b6 When you need to load a third-party object (or plugin) into your application, it is usually in order to fit a specific purpose. As such, you would expect that each plugin you load to match a particular behaviour that you can use to invoke it for this predetermined purpose. Furthermore, you would expect plugins to advertise which specific behaviours they are capable of fitting, so that your application can load and use them correctly. Hooks are grappler's abstraction of a particular behaviour that you wish to load plugins for. When you need to load plugins for a particular behaviour, you define a hook and use it to load plugins, which you can interact with to perform the functions you need. The only requirement on the application end, is that each hook must be given a static string identifier, which is called the hook's topic. Topics are simply put, a way for plugins to advertise that they are capable of satisfying a hook's behaviour. The exact details of how this is advertised, relies on which exact strategies grappler is using to load plugins. By default, topics map directly to entry point names (from setuptools). Loading Plugins with Hooks \u00b6 This can be done be instantiating a hook and iterating over it like a Python iterable: from grappler import Hook plugins = Hook ( \"some.topic\" ) for plugin in plugins : do_something_with ( plugin ) When you instantiate a hook, you must give it a topic to use. With the default loading behaviour, topics map directly to entry point names. For this reason, it is a good idea to give the topics a unique sort of prefix, so that they do not conflict with other entry point names that may have been installed into the environment. The pattern pkg.module.purpose can be a good one to use, since your package name is already unique in the installed environment. Specifying Expected Behavior \u00b6 In the example above, the plugins loaded could be any arbitrary object. Provided that your every plugin that advertises to your topic is one that implements the behavior, then this duck-typing is not such an issue. However, you may wish to have have stronger typing for mypy, or, you may wish to load variants of the same plugins from the same hook. This can be accomplished by providing the hook with a type annotation. from dataclasses import dataclass from typing import Any , Protocol , runtime_checkable from grappler import Hook topic = \"grappler-docs.example.shape\" # this hook will iterate any object on this topic hook = Hook [ Any ]( topic ) # this hook will iterate any object that is an instance of the Shape class or its # subclasses from the topic, and ignore all others @dataclass class Shape : area : float hook = Hook [ Shape ]( topic ) # this hook will iterate only objects that implements the polygon protocol from # the topic (runtime_checkable decoration required). @runtime_checkable class Polygon ( Protocol ): area : float sides : int hook = Hook [ Polygon ]( topic ) # this hook will iterate circles or squares, but nothing else @dataclass class Circle : radius : float @property def area ( self ) -> float : ... @dataclass class Square : size : float @property def area ( self ) -> float : ... hook = Hook [ Circle | Square ]( topic ) Of course, these examples are contrived for extreme simplicity, but you can define behaviors which are as complex as necessary, so long as they can be described by a protocol or an abstract class etc. Grapplers \u00b6 While hooks expose an interface to iterate plugins for a particular purpose, they do not expose much about how the plugins are loaded. Loading id done using the Grappler protocol. It describes an object that is able to find plugins and their metadata, as well as load them. Each Grappler can either act as a source for plugins, or customise the finding or loading behavior of another grappler. For example, the EntryPointGrappler finds and loads plugins that are installed for entry points in the Python environment, while BouncerGrappler wraps another grappler and blocks the finding or loading certain plugins depending on its configuration. By composing Grapplers, an application can describe a custom configuration of how to load plugins. Furthermore, new sources of plugins can be specified by implementing the protocol. Customising Loading with Grapplers \u00b6 The basic hook interface shown in this guide so far uses the default configuration. In this default config, entry points which have been installed into the Python environment are found as plugins. There is no caching or filtering applied. Applications may however wish to customise this default behavior. The grappler.grapplers module provides a few Grapplers which can be used to do this. The CompositeGrappler is the starting point from which to do this. It can be used to compose the plugins and behaviors from several grapplers into a single grappler, which can then be passed to hook in order to load plugins from: from grappler import Hook , Plugin from grappler.grapplers import ( BouncerGrappler , CompositeGrappler , EntryPointGrappler , ) def block_grappler_plugins ( plugin : Plugin ) -> bool : return not plugin . package . name . startswith ( \"grappler\" ) composite_grappler = ( CompositeGrappler () . source ( EntryPointGrappler ()) . source ( YourCustomSourceGrappler ()) . wrap ( BouncerGrappler ()) . configure ( BouncerGrappler . checker , block_grappler_plugins ) ) plugins = Hook ( \"some.topic\" , grappler = composite_grappler ) for plugin in plugins : do_something_with ( plugin ) The remaining sections will explore the various Grapplers included with the library and what you can do with them. Using BouncerGrappler to filter plugins \u00b6 The BouncerGrappler provides a generic interface that wraps another Grappler in order to filter the plugins that it finds or loads. The filtering is done using checker functions, as many of which may be supplied using BouncerGrappler.checker . Checker functions should simply return truthy if the the plugin should be allowed to load. For example, the following bouncer will block all plugins according to a blacklist: from grappler import Package , Plugin from grappler.grapplers import BouncerGrappler bouncer = BouncerGrappler () blacklisted_packages : list [ Package ] = [ ... ] @bouncer . checker def block_plugins_in_blacklist ( plugin : Plugin ) -> bool : return plugin not in blacklisted_packages Checker functions may only need to block a plugin during either finding, or loading, but not both. To do this, use the decorator with mode argument. For example, the following checker can be used to deduplicate finding plugins (when composing in such a way that creates duplicates): @bouncer . checker ( mode = BouncerGrappler . Mode . Find ) def strip_duplicate_plugins ( plugin : Plugin ) -> bool : seen_plugins = context . setdefault ( \"seen\" , set [ Plugin ]()) if plugin in seen_plugins : return False else : seen_plugins . add ( Plugin ) return True Blacklisting Plugins \u00b6 The BlacklistingGrappler wraps BouncerGrappler to perform more robust blacklisting than the earlier example. Plugins can be blacklisted individually, or entire packages may be blacklisted. from typing import Iterable from grappler import Package , Plugin from grappler.grapplers import BlacklistingGrappler # blacklist may either be provided statically blacklister = BlacklistingGrappler ( blacklist = [ * packages_or_plugins ]) # ... or dynamically blacklister = BlacklistingGrapper () @blacklister . blacklist def get_blacklisted_items () -> Iterable [ Plugin | Package ]: ...","title":"User Guide"},{"location":"user-guide/#user-guide","text":"Grappler's purpose is to provide a simple interface that you can use to load \"plugins\" into your Python application. In its default configuration, it allows you to load objects from third-party code that has been installed into the same environment as your application. This page explores how to use grappler to load plugins from third-party code. Furthermore, it will examine how to use customise grappler's loading behavior. It assumes knowledge of how to program in Python, including using type annotations, which are required for some mid-advanced features of grappler.","title":"User Guide"},{"location":"user-guide/#hooks-and-topics","text":"When you need to load a third-party object (or plugin) into your application, it is usually in order to fit a specific purpose. As such, you would expect that each plugin you load to match a particular behaviour that you can use to invoke it for this predetermined purpose. Furthermore, you would expect plugins to advertise which specific behaviours they are capable of fitting, so that your application can load and use them correctly. Hooks are grappler's abstraction of a particular behaviour that you wish to load plugins for. When you need to load plugins for a particular behaviour, you define a hook and use it to load plugins, which you can interact with to perform the functions you need. The only requirement on the application end, is that each hook must be given a static string identifier, which is called the hook's topic. Topics are simply put, a way for plugins to advertise that they are capable of satisfying a hook's behaviour. The exact details of how this is advertised, relies on which exact strategies grappler is using to load plugins. By default, topics map directly to entry point names (from setuptools).","title":"Hooks and Topics"},{"location":"user-guide/#loading-plugins-with-hooks","text":"This can be done be instantiating a hook and iterating over it like a Python iterable: from grappler import Hook plugins = Hook ( \"some.topic\" ) for plugin in plugins : do_something_with ( plugin ) When you instantiate a hook, you must give it a topic to use. With the default loading behaviour, topics map directly to entry point names. For this reason, it is a good idea to give the topics a unique sort of prefix, so that they do not conflict with other entry point names that may have been installed into the environment. The pattern pkg.module.purpose can be a good one to use, since your package name is already unique in the installed environment.","title":"Loading Plugins with Hooks"},{"location":"user-guide/#specifying-expected-behavior","text":"In the example above, the plugins loaded could be any arbitrary object. Provided that your every plugin that advertises to your topic is one that implements the behavior, then this duck-typing is not such an issue. However, you may wish to have have stronger typing for mypy, or, you may wish to load variants of the same plugins from the same hook. This can be accomplished by providing the hook with a type annotation. from dataclasses import dataclass from typing import Any , Protocol , runtime_checkable from grappler import Hook topic = \"grappler-docs.example.shape\" # this hook will iterate any object on this topic hook = Hook [ Any ]( topic ) # this hook will iterate any object that is an instance of the Shape class or its # subclasses from the topic, and ignore all others @dataclass class Shape : area : float hook = Hook [ Shape ]( topic ) # this hook will iterate only objects that implements the polygon protocol from # the topic (runtime_checkable decoration required). @runtime_checkable class Polygon ( Protocol ): area : float sides : int hook = Hook [ Polygon ]( topic ) # this hook will iterate circles or squares, but nothing else @dataclass class Circle : radius : float @property def area ( self ) -> float : ... @dataclass class Square : size : float @property def area ( self ) -> float : ... hook = Hook [ Circle | Square ]( topic ) Of course, these examples are contrived for extreme simplicity, but you can define behaviors which are as complex as necessary, so long as they can be described by a protocol or an abstract class etc.","title":"Specifying Expected Behavior"},{"location":"user-guide/#grapplers","text":"While hooks expose an interface to iterate plugins for a particular purpose, they do not expose much about how the plugins are loaded. Loading id done using the Grappler protocol. It describes an object that is able to find plugins and their metadata, as well as load them. Each Grappler can either act as a source for plugins, or customise the finding or loading behavior of another grappler. For example, the EntryPointGrappler finds and loads plugins that are installed for entry points in the Python environment, while BouncerGrappler wraps another grappler and blocks the finding or loading certain plugins depending on its configuration. By composing Grapplers, an application can describe a custom configuration of how to load plugins. Furthermore, new sources of plugins can be specified by implementing the protocol.","title":"Grapplers"},{"location":"user-guide/#customising-loading-with-grapplers","text":"The basic hook interface shown in this guide so far uses the default configuration. In this default config, entry points which have been installed into the Python environment are found as plugins. There is no caching or filtering applied. Applications may however wish to customise this default behavior. The grappler.grapplers module provides a few Grapplers which can be used to do this. The CompositeGrappler is the starting point from which to do this. It can be used to compose the plugins and behaviors from several grapplers into a single grappler, which can then be passed to hook in order to load plugins from: from grappler import Hook , Plugin from grappler.grapplers import ( BouncerGrappler , CompositeGrappler , EntryPointGrappler , ) def block_grappler_plugins ( plugin : Plugin ) -> bool : return not plugin . package . name . startswith ( \"grappler\" ) composite_grappler = ( CompositeGrappler () . source ( EntryPointGrappler ()) . source ( YourCustomSourceGrappler ()) . wrap ( BouncerGrappler ()) . configure ( BouncerGrappler . checker , block_grappler_plugins ) ) plugins = Hook ( \"some.topic\" , grappler = composite_grappler ) for plugin in plugins : do_something_with ( plugin ) The remaining sections will explore the various Grapplers included with the library and what you can do with them.","title":"Customising Loading with Grapplers"},{"location":"user-guide/#using-bouncergrappler-to-filter-plugins","text":"The BouncerGrappler provides a generic interface that wraps another Grappler in order to filter the plugins that it finds or loads. The filtering is done using checker functions, as many of which may be supplied using BouncerGrappler.checker . Checker functions should simply return truthy if the the plugin should be allowed to load. For example, the following bouncer will block all plugins according to a blacklist: from grappler import Package , Plugin from grappler.grapplers import BouncerGrappler bouncer = BouncerGrappler () blacklisted_packages : list [ Package ] = [ ... ] @bouncer . checker def block_plugins_in_blacklist ( plugin : Plugin ) -> bool : return plugin not in blacklisted_packages Checker functions may only need to block a plugin during either finding, or loading, but not both. To do this, use the decorator with mode argument. For example, the following checker can be used to deduplicate finding plugins (when composing in such a way that creates duplicates): @bouncer . checker ( mode = BouncerGrappler . Mode . Find ) def strip_duplicate_plugins ( plugin : Plugin ) -> bool : seen_plugins = context . setdefault ( \"seen\" , set [ Plugin ]()) if plugin in seen_plugins : return False else : seen_plugins . add ( Plugin ) return True","title":"Using BouncerGrappler to filter plugins"},{"location":"user-guide/#blacklisting-plugins","text":"The BlacklistingGrappler wraps BouncerGrappler to perform more robust blacklisting than the earlier example. Plugins can be blacklisted individually, or entire packages may be blacklisted. from typing import Iterable from grappler import Package , Plugin from grappler.grapplers import BlacklistingGrappler # blacklist may either be provided statically blacklister = BlacklistingGrappler ( blacklist = [ * packages_or_plugins ]) # ... or dynamically blacklister = BlacklistingGrapper () @blacklister . blacklist def get_blacklisted_items () -> Iterable [ Plugin | Package ]: ...","title":"Blacklisting Plugins"},{"location":"api/bases/","text":"Grappler Bases \u00b6 grappler.grapplers.bases \u00b6 This module contains base classes for Grapplers. BasicGrappler provides a very barebones base to build a grappler onto. It helps to properly implement the Grappler.find context managed interface. PluginPairGrapplerBase \u00b6 Bases: BasicGrappler [ Dict [ Plugin , T_Cache ]] , ABC , Generic [ T_Cache ] A grappler base that allows to pair arbitrary data with each iterated plugin, allowing for easier loading later. See grappler.grapplers.CompositeGrappler for example usage. To implement this, you must implement the iter_plugins and load_with_pair methods. iter_plugins ( topic : Optional [ str ], exit_stack : ExitStack ) -> Iterable [ Tuple [ Plugin , T_Cache ]] abstractmethod \u00b6 Return an iterator for (plugin, pair) pairs. It a topic is given, each iterated plugin must support it. If no topic is given, the any plugin may be iterated. The value returned for pair will be used with load_with_pair Source code in grappler/grapplers/bases/_plugin_pair.py 28 29 30 31 32 33 34 35 36 37 38 39 40 @abstractmethod def iter_plugins ( self , topic : Optional [ str ], exit_stack : ExitStack , / ) -> Iterable [ Tuple [ Plugin , T_Cache ]]: \"\"\" Return an iterator for (plugin, pair) pairs. It a topic is given, each iterated plugin must support it. If no topic is given, the any plugin may be iterated. The value returned for `pair` will be used with [`load_with_pair`][grappler.grapplers.bases.PluginPairGrapplerBase.load_with_pair] \"\"\" load_with_pair ( plugin : Plugin , pair : T_Cache ) -> Any abstractmethod \u00b6 Load a plugin and return it. The value for pair is passed unmodifier from iter_plugins Source code in grappler/grapplers/bases/_plugin_pair.py 42 43 44 45 46 47 48 @abstractmethod def load_with_pair ( self , plugin : Plugin , pair : T_Cache , / ) -> Any : \"\"\"Load a plugin and return it. The value for `pair` is passed unmodifier from [`iter_plugins`][grappler.grapplers.bases.PluginPairGrapplerBase.iter_plugins] \"\"\" BasicGrappler () -> None \u00b6 Bases: ABC , Generic [ T_ItConfig ] An abstract base class for a Grappler To properly implement this abstract class, both create_iteration_context() and load_from_context () must be implemented. In return, you will receive a class that is compliant with the Grappler protocol, which uses context variables to isolate iterations. It is implemented as a generic class that allows a subclass store typed state before iteration, and receive it later when loading plugins. See EntryPointGrappler source code for an example. Source code in grappler/grapplers/bases/_basic.py 57 58 def __init__ ( self ) -> None : self . __iteration_configs : Dict [ int , T_ItConfig ] = {} id () -> str property abstractmethod \u00b6 Return a globally unqiue id for the grappler. Source code in grappler/grapplers/bases/_basic.py 60 61 62 63 @property @abstractmethod def id ( self ) -> str : \"\"\"Return a globally unqiue id for the grappler.\"\"\" create_iteration_context ( topic : Optional [ str ], exit_stack : ExitStack ) -> Tuple [ Iterable [ Plugin ], T_ItConfig ] abstractmethod \u00b6 Return an iteration context for the grappler. Parameters: Name Type Description Default topic Optional [ str ] Optionally a topic to which the iterated plugins should be limited, or None if no limiting should occur. required exit_stack ExitStack A contextlib.ExitStack instance representing the iteration context. This can be used to setup context managers, ensuring that they will be torn down at the end of the iteration context. required The return value is a pair of values: an iterable of plugins a value that can store config for when load_from_context () is called. Source code in grappler/grapplers/bases/_basic.py 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 @abstractmethod def create_iteration_context ( self , topic : Optional [ str ], exit_stack : ExitStack , / ) -> Tuple [ Iterable [ Plugin ], T_ItConfig ]: \"\"\" Return an iteration context for the grappler. Args: topic: Optionally a topic to which the iterated plugins should be limited, or `None` if no limiting should occur. exit_stack: A `contextlib.ExitStack` instance representing the iteration context. This can be used to setup context managers, ensuring that they will be torn down at the end of the iteration context. The return value is a pair of values: - an iterable of plugins - a value that can store config for when [`load_from_context()`][grappler.grapplers.bases.BasicGrappler.load_from_context] is called. \"\"\" raise NotImplementedError load_from_context ( plugin : Plugin , context : T_ItConfig ) -> Any abstractmethod \u00b6 Load a plugin and return its value. Parameters: Name Type Description Default plugin Plugin Plugin to be loaded, which comes from the iterator returned from create_iteration_context() required context T_ItConfig Context value which was returned from create_iteration_context . required Source code in grappler/grapplers/bases/_basic.py 92 93 94 95 96 97 98 99 100 101 102 103 104 @abstractmethod def load_from_context ( self , plugin : Plugin , context : T_ItConfig , / ) -> Any : \"\"\" Load a plugin and return its value. Args: plugin: Plugin to be loaded, which comes from the iterator returned from [`create_iteration_context()`][grappler.grapplers.bases.BasicGrappler.create_iteration_context] context: Context value which was returned from `create_iteration_context`. \"\"\" raise NotImplementedError cleanup_iteration_context ( context : T_ItConfig ) -> None \u00b6 Cleanup an iteration context. This method can be used to cleanup dangling resources that were created in create_iteration_context() . The default implementation does nothing. Source code in grappler/grapplers/bases/_basic.py 106 107 108 109 110 111 112 113 114 115 def cleanup_iteration_context ( self , context : T_ItConfig ) -> None : \"\"\" Cleanup an iteration context. This method can be used to cleanup dangling resources that were created in [`create_iteration_context()`][grappler.grapplers.bases.BasicGrappler.create_iteration_context]. The default implementation does nothing. \"\"\"","title":"Grappler Bases"},{"location":"api/bases/#grappler-bases","text":"","title":"Grappler Bases"},{"location":"api/bases/#grappler.grapplers.bases","text":"This module contains base classes for Grapplers. BasicGrappler provides a very barebones base to build a grappler onto. It helps to properly implement the Grappler.find context managed interface.","title":"bases"},{"location":"api/bases/#grappler.grapplers.bases.PluginPairGrapplerBase","text":"Bases: BasicGrappler [ Dict [ Plugin , T_Cache ]] , ABC , Generic [ T_Cache ] A grappler base that allows to pair arbitrary data with each iterated plugin, allowing for easier loading later. See grappler.grapplers.CompositeGrappler for example usage. To implement this, you must implement the iter_plugins and load_with_pair methods.","title":"PluginPairGrapplerBase"},{"location":"api/bases/#grappler.grapplers.bases._plugin_pair.PluginPairGrapplerBase.iter_plugins","text":"Return an iterator for (plugin, pair) pairs. It a topic is given, each iterated plugin must support it. If no topic is given, the any plugin may be iterated. The value returned for pair will be used with load_with_pair Source code in grappler/grapplers/bases/_plugin_pair.py 28 29 30 31 32 33 34 35 36 37 38 39 40 @abstractmethod def iter_plugins ( self , topic : Optional [ str ], exit_stack : ExitStack , / ) -> Iterable [ Tuple [ Plugin , T_Cache ]]: \"\"\" Return an iterator for (plugin, pair) pairs. It a topic is given, each iterated plugin must support it. If no topic is given, the any plugin may be iterated. The value returned for `pair` will be used with [`load_with_pair`][grappler.grapplers.bases.PluginPairGrapplerBase.load_with_pair] \"\"\"","title":"iter_plugins()"},{"location":"api/bases/#grappler.grapplers.bases._plugin_pair.PluginPairGrapplerBase.load_with_pair","text":"Load a plugin and return it. The value for pair is passed unmodifier from iter_plugins Source code in grappler/grapplers/bases/_plugin_pair.py 42 43 44 45 46 47 48 @abstractmethod def load_with_pair ( self , plugin : Plugin , pair : T_Cache , / ) -> Any : \"\"\"Load a plugin and return it. The value for `pair` is passed unmodifier from [`iter_plugins`][grappler.grapplers.bases.PluginPairGrapplerBase.iter_plugins] \"\"\"","title":"load_with_pair()"},{"location":"api/bases/#grappler.grapplers.bases.BasicGrappler","text":"Bases: ABC , Generic [ T_ItConfig ] An abstract base class for a Grappler To properly implement this abstract class, both create_iteration_context() and load_from_context () must be implemented. In return, you will receive a class that is compliant with the Grappler protocol, which uses context variables to isolate iterations. It is implemented as a generic class that allows a subclass store typed state before iteration, and receive it later when loading plugins. See EntryPointGrappler source code for an example. Source code in grappler/grapplers/bases/_basic.py 57 58 def __init__ ( self ) -> None : self . __iteration_configs : Dict [ int , T_ItConfig ] = {}","title":"BasicGrappler"},{"location":"api/bases/#grappler.grapplers.bases._basic.BasicGrappler.id","text":"Return a globally unqiue id for the grappler. Source code in grappler/grapplers/bases/_basic.py 60 61 62 63 @property @abstractmethod def id ( self ) -> str : \"\"\"Return a globally unqiue id for the grappler.\"\"\"","title":"id()"},{"location":"api/bases/#grappler.grapplers.bases._basic.BasicGrappler.create_iteration_context","text":"Return an iteration context for the grappler. Parameters: Name Type Description Default topic Optional [ str ] Optionally a topic to which the iterated plugins should be limited, or None if no limiting should occur. required exit_stack ExitStack A contextlib.ExitStack instance representing the iteration context. This can be used to setup context managers, ensuring that they will be torn down at the end of the iteration context. required The return value is a pair of values: an iterable of plugins a value that can store config for when load_from_context () is called. Source code in grappler/grapplers/bases/_basic.py 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 @abstractmethod def create_iteration_context ( self , topic : Optional [ str ], exit_stack : ExitStack , / ) -> Tuple [ Iterable [ Plugin ], T_ItConfig ]: \"\"\" Return an iteration context for the grappler. Args: topic: Optionally a topic to which the iterated plugins should be limited, or `None` if no limiting should occur. exit_stack: A `contextlib.ExitStack` instance representing the iteration context. This can be used to setup context managers, ensuring that they will be torn down at the end of the iteration context. The return value is a pair of values: - an iterable of plugins - a value that can store config for when [`load_from_context()`][grappler.grapplers.bases.BasicGrappler.load_from_context] is called. \"\"\" raise NotImplementedError","title":"create_iteration_context()"},{"location":"api/bases/#grappler.grapplers.bases._basic.BasicGrappler.load_from_context","text":"Load a plugin and return its value. Parameters: Name Type Description Default plugin Plugin Plugin to be loaded, which comes from the iterator returned from create_iteration_context() required context T_ItConfig Context value which was returned from create_iteration_context . required Source code in grappler/grapplers/bases/_basic.py 92 93 94 95 96 97 98 99 100 101 102 103 104 @abstractmethod def load_from_context ( self , plugin : Plugin , context : T_ItConfig , / ) -> Any : \"\"\" Load a plugin and return its value. Args: plugin: Plugin to be loaded, which comes from the iterator returned from [`create_iteration_context()`][grappler.grapplers.bases.BasicGrappler.create_iteration_context] context: Context value which was returned from `create_iteration_context`. \"\"\" raise NotImplementedError","title":"load_from_context()"},{"location":"api/bases/#grappler.grapplers.bases._basic.BasicGrappler.cleanup_iteration_context","text":"Cleanup an iteration context. This method can be used to cleanup dangling resources that were created in create_iteration_context() . The default implementation does nothing. Source code in grappler/grapplers/bases/_basic.py 106 107 108 109 110 111 112 113 114 115 def cleanup_iteration_context ( self , context : T_ItConfig ) -> None : \"\"\" Cleanup an iteration context. This method can be used to cleanup dangling resources that were created in [`create_iteration_context()`][grappler.grapplers.bases.BasicGrappler.create_iteration_context]. The default implementation does nothing. \"\"\"","title":"cleanup_iteration_context()"},{"location":"api/core/","text":"Core API \u00b6 grappler \u00b6 The grappler module contains everything you need to get started using grappler. The main entry point is the Hook class. Package \u00b6 Bases: NamedTuple A logical collection of plugins name : str class-attribute \u00b6 A name for the package which may be displayed to a human. version : str class-attribute \u00b6 A version number for the package. id : str class-attribute \u00b6 A unique identifier for the package. platform : Optional [ str ] class-attribute \u00b6 The package platform (sys.platform compatible value, if any) Hook ( topic : str , * , grappler : Optional [ Grappler ] = None ) -> None \u00b6 Bases: Generic [ T ] An abstraction for loading plugins providing a specific behavior. Hooks provide an iterable interface for loaded plugin values. This allows to define a hook with a topic to load plugins for, and then iterate over the hook in order to access the externally loaded objects. Furthermore, the iterated objects can be further restricted by providing a type argument to the hook; when this is done, any externally loaded object that is not an instance of the given type is skipped. Type arguments to Hook must be usable in isinstance check The type argument given to the hook class should be usable as the second argument to Python's isinstance . Failing this constraint will result in a type error upon iteration (notable exception: Any may be used). This means that some types which are otherwise valid are not usable in this context (e.g. None or Callable[...] ). Parameters: Name Type Description Default topic str An arbitrary string identifier for the behavior that your hook will load plugins for. The hook will then only load plugins that advertise the topic given here. required grappler Optional [ Grappler ] When given, it should be a Grappler which will be used to find and load plugins. If not given, then an unmodified instance of EntryPointGrappler is used. See the Customising Loading section of the user guide, which gives an explanation of how to setup a grappler for more complex loading behavior. None Usage: # iterate the hook to load all plugins from the topic. from grappler import Hook objs = list ( Hook ( \"topic.counter-functions\" )) # use a type argument to restrict the objects that are returned. from typing import Any , Protocol , runtime_checkable from grappler import Hook @runtime_checkable class CounterFunction ( Protocol ): def __call__ ( self , items : Any ) -> int : ... counter_functions = list ( Hook [ CounterFunction ]( \"topic.counter-functions\" )) # (note: argument specs are not checked for callable Protocol # instance checks; the mere presence of a `__call__` method will satisfy # the hook's filter. This is due to how `isinstance` works in Python.) Source code in grappler/_hook.py 81 82 83 84 def __init__ ( self , topic : str , * , grappler : Optional [ Grappler ] = None ) -> None : self . topic = topic self . grappler = grappler or EntryPointGrappler () self . _loaded : Set [ Plugin ] = set () __iter__ () -> Iterator [ T ] \u00b6 Return an iterator to loaded plugin objects from the hook's topic. If the hook was instantiated with a type argument, then only objects which pass isinstance(obj, T) are included in the iterator. Source code in grappler/_hook.py 86 87 88 89 90 91 92 def __iter__ ( self ) -> Iterator [ T ]: \"\"\"Return an iterator to loaded plugin objects from the hook's topic. If the hook was instantiated with a type argument, then only objects which pass `isinstance(obj, T)` are included in the iterator. \"\"\" return self . _iter_grappler ( self . grappler ) loaded_plugins () -> Collection [ Plugin ] property \u00b6 Return a collection containing all plugins loaded by the hook so far. Source code in grappler/_hook.py 94 95 96 97 98 99 100 @property def loaded_plugins ( self ) -> Collection [ Plugin ]: \"\"\" Return a collection containing all plugins loaded by the hook so far. \"\"\" return list ( self . _loaded ) Plugin dataclass \u00b6 An external, loadable Python object grappler_id : str class-attribute \u00b6 The id of the grappler that the plugin came from. plugin_id : str class-attribute \u00b6 A unique identifier for the plugin. package : Package class-attribute \u00b6 A struct containing more information about the package containing the plugin topics : Tuple [ str , ... ] class-attribute \u00b6 A tuple of topics that the plugin advertises. name : Optional [ str ] class-attribute \u00b6 A name for the plugin which may be displayed to a human. Grappler \u00b6 Bases: Protocol General protocol for an object that can find and load plugins. id () -> str property \u00b6 A globally unique identifier for the grappler. Source code in grappler/_types.py 61 62 63 @property def id ( self ) -> str : \"\"\"A globally unique identifier for the grappler.\"\"\" find ( topic : Optional [ str ] = None ) -> ContextManager [ Iterator [ Plugin ]] \u00b6 Return a context managed iterator of plugins that this grappler can load. Implementors of this protocol only need to make sure that the plugins can be loaded when the returned context manager is still open; once the context closes, then it is not required for the returned plugins to still be loadable. Source code in grappler/_types.py 65 66 67 68 69 70 71 72 73 74 def find ( self , topic : Optional [ str ] = None ) -> ContextManager [ Iterator [ Plugin ]]: \"\"\" Return a context managed iterator of plugins that this grappler can load. Implementors of this protocol only need to make sure that the plugins can be loaded when the returned context manager is still open; once the context closes, then it is not required for the returned plugins to still be loadable. \"\"\" load ( plugin : Plugin ) -> Any \u00b6 Load an object out of an plugin. May raise an UnknownPluginError if the plugin type is not recognised by the grappler. (This may happen even when supplied a plugin which originated in the grappler, but it's find context is already closed.) Source code in grappler/_types.py 76 77 78 79 80 81 82 83 def load ( self , plugin : Plugin ) -> Any : \"\"\"Load an object out of an plugin. May raise an UnknownPluginError if the plugin type is not recognised by the grappler. (This may happen even when supplied a plugin which originated in the grappler, but it's find context is already closed.) \"\"\" UnknownPluginError ( plugin : Plugin , grappler : Grappler ) -> None \u00b6 Bases: LookupError Raised when a grappler is asked to load an plugin it doesn't know how to. Source code in grappler/_types.py 89 90 91 92 93 94 95 96 def __init__ ( self , plugin : Plugin , grappler : Grappler ) -> None : super () . __init__ ( self , f \"Grappler (id= { repr ( grappler . id ) } ) does not know \" f \"how to load plugin: { plugin } \" , ) self . plugin = plugin self . grappler = grappler","title":"Core API"},{"location":"api/core/#core-api","text":"","title":"Core API"},{"location":"api/core/#grappler","text":"The grappler module contains everything you need to get started using grappler. The main entry point is the Hook class.","title":"grappler"},{"location":"api/core/#grappler.Package","text":"Bases: NamedTuple A logical collection of plugins","title":"Package"},{"location":"api/core/#grappler._types.Package.name","text":"A name for the package which may be displayed to a human.","title":"name"},{"location":"api/core/#grappler._types.Package.version","text":"A version number for the package.","title":"version"},{"location":"api/core/#grappler._types.Package.id","text":"A unique identifier for the package.","title":"id"},{"location":"api/core/#grappler._types.Package.platform","text":"The package platform (sys.platform compatible value, if any)","title":"platform"},{"location":"api/core/#grappler.Hook","text":"Bases: Generic [ T ] An abstraction for loading plugins providing a specific behavior. Hooks provide an iterable interface for loaded plugin values. This allows to define a hook with a topic to load plugins for, and then iterate over the hook in order to access the externally loaded objects. Furthermore, the iterated objects can be further restricted by providing a type argument to the hook; when this is done, any externally loaded object that is not an instance of the given type is skipped. Type arguments to Hook must be usable in isinstance check The type argument given to the hook class should be usable as the second argument to Python's isinstance . Failing this constraint will result in a type error upon iteration (notable exception: Any may be used). This means that some types which are otherwise valid are not usable in this context (e.g. None or Callable[...] ). Parameters: Name Type Description Default topic str An arbitrary string identifier for the behavior that your hook will load plugins for. The hook will then only load plugins that advertise the topic given here. required grappler Optional [ Grappler ] When given, it should be a Grappler which will be used to find and load plugins. If not given, then an unmodified instance of EntryPointGrappler is used. See the Customising Loading section of the user guide, which gives an explanation of how to setup a grappler for more complex loading behavior. None Usage: # iterate the hook to load all plugins from the topic. from grappler import Hook objs = list ( Hook ( \"topic.counter-functions\" )) # use a type argument to restrict the objects that are returned. from typing import Any , Protocol , runtime_checkable from grappler import Hook @runtime_checkable class CounterFunction ( Protocol ): def __call__ ( self , items : Any ) -> int : ... counter_functions = list ( Hook [ CounterFunction ]( \"topic.counter-functions\" )) # (note: argument specs are not checked for callable Protocol # instance checks; the mere presence of a `__call__` method will satisfy # the hook's filter. This is due to how `isinstance` works in Python.) Source code in grappler/_hook.py 81 82 83 84 def __init__ ( self , topic : str , * , grappler : Optional [ Grappler ] = None ) -> None : self . topic = topic self . grappler = grappler or EntryPointGrappler () self . _loaded : Set [ Plugin ] = set ()","title":"Hook"},{"location":"api/core/#grappler._hook.Hook.__iter__","text":"Return an iterator to loaded plugin objects from the hook's topic. If the hook was instantiated with a type argument, then only objects which pass isinstance(obj, T) are included in the iterator. Source code in grappler/_hook.py 86 87 88 89 90 91 92 def __iter__ ( self ) -> Iterator [ T ]: \"\"\"Return an iterator to loaded plugin objects from the hook's topic. If the hook was instantiated with a type argument, then only objects which pass `isinstance(obj, T)` are included in the iterator. \"\"\" return self . _iter_grappler ( self . grappler )","title":"__iter__()"},{"location":"api/core/#grappler._hook.Hook.loaded_plugins","text":"Return a collection containing all plugins loaded by the hook so far. Source code in grappler/_hook.py 94 95 96 97 98 99 100 @property def loaded_plugins ( self ) -> Collection [ Plugin ]: \"\"\" Return a collection containing all plugins loaded by the hook so far. \"\"\" return list ( self . _loaded )","title":"loaded_plugins()"},{"location":"api/core/#grappler.Plugin","text":"An external, loadable Python object","title":"Plugin"},{"location":"api/core/#grappler._types.Plugin.grappler_id","text":"The id of the grappler that the plugin came from.","title":"grappler_id"},{"location":"api/core/#grappler._types.Plugin.plugin_id","text":"A unique identifier for the plugin.","title":"plugin_id"},{"location":"api/core/#grappler._types.Plugin.package","text":"A struct containing more information about the package containing the plugin","title":"package"},{"location":"api/core/#grappler._types.Plugin.topics","text":"A tuple of topics that the plugin advertises.","title":"topics"},{"location":"api/core/#grappler._types.Plugin.name","text":"A name for the plugin which may be displayed to a human.","title":"name"},{"location":"api/core/#grappler.Grappler","text":"Bases: Protocol General protocol for an object that can find and load plugins.","title":"Grappler"},{"location":"api/core/#grappler._types.Grappler.id","text":"A globally unique identifier for the grappler. Source code in grappler/_types.py 61 62 63 @property def id ( self ) -> str : \"\"\"A globally unique identifier for the grappler.\"\"\"","title":"id()"},{"location":"api/core/#grappler._types.Grappler.find","text":"Return a context managed iterator of plugins that this grappler can load. Implementors of this protocol only need to make sure that the plugins can be loaded when the returned context manager is still open; once the context closes, then it is not required for the returned plugins to still be loadable. Source code in grappler/_types.py 65 66 67 68 69 70 71 72 73 74 def find ( self , topic : Optional [ str ] = None ) -> ContextManager [ Iterator [ Plugin ]]: \"\"\" Return a context managed iterator of plugins that this grappler can load. Implementors of this protocol only need to make sure that the plugins can be loaded when the returned context manager is still open; once the context closes, then it is not required for the returned plugins to still be loadable. \"\"\"","title":"find()"},{"location":"api/core/#grappler._types.Grappler.load","text":"Load an object out of an plugin. May raise an UnknownPluginError if the plugin type is not recognised by the grappler. (This may happen even when supplied a plugin which originated in the grappler, but it's find context is already closed.) Source code in grappler/_types.py 76 77 78 79 80 81 82 83 def load ( self , plugin : Plugin ) -> Any : \"\"\"Load an object out of an plugin. May raise an UnknownPluginError if the plugin type is not recognised by the grappler. (This may happen even when supplied a plugin which originated in the grappler, but it's find context is already closed.) \"\"\"","title":"load()"},{"location":"api/core/#grappler.UnknownPluginError","text":"Bases: LookupError Raised when a grappler is asked to load an plugin it doesn't know how to. Source code in grappler/_types.py 89 90 91 92 93 94 95 96 def __init__ ( self , plugin : Plugin , grappler : Grappler ) -> None : super () . __init__ ( self , f \"Grappler (id= { repr ( grappler . id ) } ) does not know \" f \"how to load plugin: { plugin } \" , ) self . plugin = plugin self . grappler = grappler","title":"UnknownPluginError"},{"location":"api/grapplers/","text":"Grapplers (Custom loading behavior) \u00b6 grappler.grapplers \u00b6 This module contains all of the grappler implementations that are provided with the package. StaticGrappler ( * objs : Tuple [ Collection [ str ], Any ], package : Optional [ Package ] = None ) -> None \u00b6 Bases: BasicGrappler [ Dict [ Plugin , Any ]] A grappler for loading \"plugins\" supplied by the host application. This is provided as a useful tool to help modularize application code, so that application components can be loaded in the same way as plugins. To use this, supply an object as well as topics that each object implements to either __init__ or add_plugin , and the grappler will generate the appropriate Plugin tuples. The plugin.package is the same for every plugin yielded by an instance of this grappler. If a package argument is provided to the constructor, then this is used. Otherwise, a default internal package is used ( StaticGrappler.internal_package ). Usage: grappler = StaticGrappler ( ([ \"list\" , \"of\" , \"topics\" ], obj ), ... ) grappler . add_plugin ([ \"topics\" , \"list\" ], obj2 ) Source code in grappler/grapplers/_static.py 48 49 50 51 52 53 54 55 56 def __init__ ( self , * objs : Tuple [ Collection [ str ], Any ], package : Optional [ Package ] = None ) -> None : self . package = package or self . internal_package self . cache = { Plugin ( self . id , str ( uuid4 ()), self . package , tuple ( topics ), name = None ): obj for topics , obj in objs } add_plugin ( item : Union [ Collection [ str ], Plugin ], / , plugin_obj : Any ) -> None \u00b6 Add an static plugin to the grappler. Source code in grappler/grapplers/_static.py 58 59 60 61 62 63 64 65 66 67 def add_plugin ( self , item : Union [ Collection [ str ], Plugin ], / , plugin_obj : Any ) -> None : \"\"\"Add an static plugin to the grappler.\"\"\" plugin = ( item if isinstance ( item , Plugin ) else Plugin ( self . id , str ( uuid4 ()), self . package , tuple ( item ), name = None ) ) self . cache [ plugin ] = plugin_obj EntryPointGrappler () -> None \u00b6 Bases: PluginPairGrapplerBase [ metadata . EntryPoint ] A Grappler for loading objects from entry points. Plugins are loaded from setuptools entry points installed in the Python environment. Entry point groups are mapped 1:1 to topics. Currently, every plugin.package.platform returned from this grappler is None , even when this value is provided by underlying metadata. Additionally, the returned plugin ids are stable across interpreter instances; this means that the plugin_id value for a given entry point definition will be the same each time this grappler iterates, between different executions of a program. This makes the grappler suitable for use with BlacklistingGrappler . Usage: grappler = EntryPointGrappler () Source code in grappler/grapplers/_entry_point.py 52 53 def __init__ ( self ) -> None : self . _groups = metadata . entry_points () BouncerGrappler ( inner : Optional [ Grappler ] = None ) -> None \u00b6 Bases: PluginPairGrapplerBase [None] Restrict plugins from an inner grappler based on rules defined as predicates. Source code in grappler/grapplers/_bouncer.py 85 86 87 def __init__ ( self , inner : Optional [ Grappler ] = None ) -> None : self . wrapped = inner self . _checks = Checks ( find = [], load = []) Mode \u00b6 Bases: Enum Operating mode for checker functions. FIND = 'find' class-attribute \u00b6 For checker functions that should only be used during the grappler's scan operation. A plugin that is blocked during this operation will never be seen by grappler's client. LOAD = 'load' class-attribute \u00b6 For checker functions that should only be used during the grappler's load operation. If a plugin is blocked during this operation, an exception will be raised when attempting to load it. checker ( checker : Optional [ F_Checker ] = None , * , mode : Mode = Mode . BOTH ) -> Union [ F_Checker , Callable [[ F_Checker ], F_Checker ]] \u00b6 Register a checker function for the bouncer. This function can be used as a decorator, or called directly: bouncer = BouncerGrappler ( ... ) @bouncer . checker def check_plugin ( plugin : Plugin ) -> bool ... @bouncer . checker ( mode = bouncer . Mode . LOAD ) def check_before_loading_only ( plugin : Plugin ) -> bool ... def check_during_find_only ( plugin : Plugin ) -> bool : ... bouncer . checker ( check_during_find_only , mode = bouncer . Mode . FIND ) Source code in grappler/grapplers/_bouncer.py 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 def checker ( self , checker : Optional [ F_Checker ] = None , * , mode : Mode = Mode . BOTH ) -> Union [ F_Checker , Callable [[ F_Checker ], F_Checker ]]: \"\"\"Register a checker function for the bouncer. This function can be used as a decorator, or called directly: ```python bouncer = BouncerGrappler(...) @bouncer.checker def check_plugin(plugin: Plugin) -> bool ... @bouncer.checker(mode=bouncer.Mode.LOAD) def check_before_loading_only(plugin: Plugin) -> bool ... def check_during_find_only(plugin: Plugin) -> bool: ... bouncer.checker(check_during_find_only, mode=bouncer.Mode.FIND) ``` \"\"\" def decorate ( f : F_Checker ) -> F_Checker : if mode in ( self . Mode . FIND , self . Mode . BOTH ): self . _checks [ \"find\" ] . append ( f ) elif mode in ( self . Mode . LOAD , self . Mode . BOTH ): self . _checks [ \"load\" ] . append ( f ) else : raise ValueError ( f \"Invalid check mode: { mode } \" ) return f if checker is not None : return decorate ( checker ) else : return decorate CompositeGrappler ( * sources : Grappler ) -> None \u00b6 Bases: BasicGrappler [ CompositeGrapplerIterationConfig ] Combine plugins and behaviors from multiple grapplers. The types of grappler you can wrap with this are divided into two categories: sources \u2013 A source grappler that provides plugins. Multiple of these may be provided, in which case the plugins will be chained in the order the grapplers were supplied in. These are provided to source() wrappers \u2013 A special grappler that can act as a middleware, adding special behavior. Every grappler in the grappler.grapplers module which wraps a single grappler (e.g. BouncerGrappler ) may be used as a wrapper. If there is more than one wrapper, then they are executed in the order which they were provided in. They are provided to wrap() Source code in grappler/grapplers/_composite.py 94 95 96 97 def __init__ ( self , * sources : Grappler ) -> None : self . _sources = list ( sources ) self . _wrappers : List [ _WrappingGrappler ] = [] self . _groups : Dict [ str , List [ Grappler ]] = {} source ( source : Grappler , / , * , group : Optional [ str ] = None ) -> CompositeGrappler \u00b6 Add a source to the CompositeGrappler . See configure_group() for the meaning of group . Source code in grappler/grapplers/_composite.py 99 100 101 102 103 104 105 106 107 108 109 110 111 112 def source ( self , source : Grappler , / , * , group : Optional [ str ] = None ) -> \"CompositeGrappler\" : \"\"\"Add a source to the `CompositeGrappler`. See [`configure_group()`][grappler.grapplers.CompositeGrappler.configure_group] for the meaning of `group`. \"\"\" self . _sources . append ( source ) if group : self . _groups . setdefault ( group , []) . append ( source ) return self wrap ( wrapper : _WrappingGrappler , / , * , group : Optional [ str ] = None ) -> CompositeGrappler \u00b6 Add a wrapper to the CompositeGrappler . The grappler will be used to wrap a virtual grappler that is created from all the sources. If more than one wrapper is used, then they will be chained in the order provided. See configure_group() for the meaning of group . Source code in grappler/grapplers/_composite.py 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 def wrap ( self , wrapper : _WrappingGrappler , / , * , group : Optional [ str ] = None ) -> \"CompositeGrappler\" : \"\"\"Add a wrapper to the `CompositeGrappler`. The grappler will be used to wrap a virtual grappler that is created from all the sources. If more than one wrapper is used, then they will be chained in the order provided. See [`configure_group()`][grappler.grapplers.CompositeGrappler.configure_group] for the meaning of `group`. \"\"\" self . _wrappers . append ( wrapper ) if group : self . _groups . setdefault ( group , []) . append ( wrapper ) return self configure ( target : Callable [ Concatenate [ Any , P_Configure ], Any ], * args : P_Configure . args , ** kwargs : P_Configure . kwargs ) -> CompositeGrappler \u00b6 Call configuration functions on matching internal grapplers. Grapplers are matched based on the host class of the configuration method passed as target . For example, is target=BouncerGrappler.checker is given, then .checker (...) will be called on every BouncerGrappler instance kept internally, with the given arguments. This method is applied immediately, and matched against the currently registered grapplers. Beware, the type definition for target is not fully correct. When using with a type checker, it is possible that this will allow values that will be rejected at runtime; please test thoroughly. Source code in grappler/grapplers/_composite.py 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 def configure ( self , target : Callable [ Concatenate [ Any , P_Configure ], Any ], * args : P_Configure . args , ** kwargs : P_Configure . kwargs , ) -> \"CompositeGrappler\" : \"\"\" Call configuration functions on matching internal grapplers. Grapplers are matched based on the host class of the configuration method passed as `target`. For example, is `target=BouncerGrappler.checker` is given, then `.checker(...)` will be called on every `BouncerGrappler` instance kept internally, with the given arguments. This method is applied immediately, and matched against the currently registered grapplers. Beware, the type definition for `target` is not fully correct. When using with a type checker, it is possible that this will allow values that will be rejected at runtime; please test thoroughly. \"\"\" return self . _configure ( None , target , * args , ** kwargs ) configure_group ( group : str , target : Callable [ Concatenate [ Any , P_Configure ], Any ], / , * args : P_Configure . args , ** kwargs : P_Configure . kwargs ) -> CompositeGrappler \u00b6 A version of configure() for use with named groups. It will further narrow the matched grapplers to only those is the named group. Named groups are created by passing the group parameter to source() or wrap() . This allows to configure only grapplers with a matching group name. Source code in grappler/grapplers/_composite.py 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 def configure_group ( self , group : str , target : Callable [ Concatenate [ Any , P_Configure ], Any ], / , * args : P_Configure . args , ** kwargs : P_Configure . kwargs , ) -> \"CompositeGrappler\" : \"\"\" A version of [`configure()`][grappler.grapplers.CompositeGrappler.configure] for use with named groups. It will further narrow the matched grapplers to only those is the named group. Named groups are created by passing the `group` parameter to `source()` or `wrap()`. This allows to configure only grapplers with a matching group name. \"\"\" return self . _configure ( group , target , * args , ** kwargs ) BlacklistingGrappler ( inner : Optional [ Grappler ] = None , items : Collection [ Union [ Plugin , Package ]] = ()) -> None \u00b6 Bases: BouncerGrappler , _ListGrapplerMixin A grappler which allows to blacklist plugins or packages. Blacklisted plugins will be blocked from iteration and loading. When a package is blacklisted, all plugins from it will be blocked. Source code in grappler/grapplers/_list.py 187 188 189 190 191 192 193 194 195 196 def __init__ ( self , inner : Optional [ Grappler ] = None , items : Collection [ Union [ Plugin , Package ]] = (), ) -> None : BouncerGrappler . __init__ ( self , inner ) _ListGrapplerMixin . __init__ ( self , items ) # Install BouncerGrappler.checker to reject listed plugins self . checker ( self . _is_not_listed ) blacklist = _ListGrapplerMixin . _add_item class-attribute \u00b6 Add an item to the blacklist. The grappler will skip any plugins that matches a blacklisted item, ensuring that they will not be loaded. This is an instance method with the following signatures: grappler . blacklist ( plugin_or_package : Union [ Plugin , Package ]) -> None : ... @grappler . blacklist def get_blacklisted_plugins () -> List [ Union [ Plugin , Package ]]: return [ ... ] These forms will blacklist plugins or entire packages by their ids . This means that no attempts will be made to match names or any other fields on the plugin on package before blocking it. Structural matching \u00b6 There are two additional signatures which perform a somewhat more structural matching (and therefore blacklisting) of plugins and packages using dictionary specifications: grappler . blacklist ({ \"name\" : \"a-plugin-name\" , \"topics\" : [ \"pytest11\" ]}, type = \"plugin\" ) grappler . blacklist ({ \"platform\" : [ \"win32\" , \"mac\" ]}, type = \"package\" ) In this form, a dictionary spec is given for matching, as well as the type argument. type must be passed as a keyword and must be either \"plugin\" or \"package\" , indicating what kind of specification is being passed in. A type of structural matching is performed on the item, in order to determine if each encountered plugin/package should be blacklisted. Every field in the dictionary is checked as an attribute of either the plugin or package , and a match is determined based on these rules: If the attribute is not present on the plugin/package, there is no match. If the field in the specification is a python collection: if the attribute is also a collection, then it matches only when the attribute is a superset of the specified collection. e.g. the \"topics\" field of the plugin specification above can match plugins which have plugin.topics == (\"pytest11\",) or plugin.topics == (\"foo\", \"pytest11\", \"bar\") etc. if the attribute is not a collection, then it matches only when the attribute is contained within e.g. the package specification above will blacklist only packages that either have package.platform == 'win32' or package.platform == 'mac' . In all other cases, a match only occurs when the attribute is equal to the field specification. All fields in the specification must match a plugin/package for it to be blacklisted. WhitelistingGrappler ( inner : Optional [ Grappler ] = None , items : Collection [ Union [ Plugin , Package ]] = ()) -> None \u00b6 Bases: BouncerGrappler , _ListGrapplerMixin A grappler which allows to whitelist plugins or packages Source code in grappler/grapplers/_list.py 278 279 280 281 282 283 284 285 286 287 def __init__ ( self , inner : Optional [ Grappler ] = None , items : Collection [ Union [ Plugin , Package ]] = (), ) -> None : BouncerGrappler . __init__ ( self , inner ) _ListGrapplerMixin . __init__ ( self , items ) # Install BouncerGrappler.checker to reject non listed plugins self . checker ( self . _is_listed ) whitelist = _ListGrapplerMixin . _add_item class-attribute \u00b6 Add an item to the whitelist. The grappler will skip all items unless they are in the whitelist. This function has the same signature as BlacklistingGrappler.blacklist()","title":"Grapplers (Custom loading behavior)"},{"location":"api/grapplers/#grapplers-custom-loading-behavior","text":"","title":"Grapplers (Custom loading behavior)"},{"location":"api/grapplers/#grappler.grapplers","text":"This module contains all of the grappler implementations that are provided with the package.","title":"grapplers"},{"location":"api/grapplers/#grappler.grapplers.StaticGrappler","text":"Bases: BasicGrappler [ Dict [ Plugin , Any ]] A grappler for loading \"plugins\" supplied by the host application. This is provided as a useful tool to help modularize application code, so that application components can be loaded in the same way as plugins. To use this, supply an object as well as topics that each object implements to either __init__ or add_plugin , and the grappler will generate the appropriate Plugin tuples. The plugin.package is the same for every plugin yielded by an instance of this grappler. If a package argument is provided to the constructor, then this is used. Otherwise, a default internal package is used ( StaticGrappler.internal_package ). Usage: grappler = StaticGrappler ( ([ \"list\" , \"of\" , \"topics\" ], obj ), ... ) grappler . add_plugin ([ \"topics\" , \"list\" ], obj2 ) Source code in grappler/grapplers/_static.py 48 49 50 51 52 53 54 55 56 def __init__ ( self , * objs : Tuple [ Collection [ str ], Any ], package : Optional [ Package ] = None ) -> None : self . package = package or self . internal_package self . cache = { Plugin ( self . id , str ( uuid4 ()), self . package , tuple ( topics ), name = None ): obj for topics , obj in objs }","title":"StaticGrappler"},{"location":"api/grapplers/#grappler.grapplers._static.StaticGrappler.add_plugin","text":"Add an static plugin to the grappler. Source code in grappler/grapplers/_static.py 58 59 60 61 62 63 64 65 66 67 def add_plugin ( self , item : Union [ Collection [ str ], Plugin ], / , plugin_obj : Any ) -> None : \"\"\"Add an static plugin to the grappler.\"\"\" plugin = ( item if isinstance ( item , Plugin ) else Plugin ( self . id , str ( uuid4 ()), self . package , tuple ( item ), name = None ) ) self . cache [ plugin ] = plugin_obj","title":"add_plugin()"},{"location":"api/grapplers/#grappler.grapplers.EntryPointGrappler","text":"Bases: PluginPairGrapplerBase [ metadata . EntryPoint ] A Grappler for loading objects from entry points. Plugins are loaded from setuptools entry points installed in the Python environment. Entry point groups are mapped 1:1 to topics. Currently, every plugin.package.platform returned from this grappler is None , even when this value is provided by underlying metadata. Additionally, the returned plugin ids are stable across interpreter instances; this means that the plugin_id value for a given entry point definition will be the same each time this grappler iterates, between different executions of a program. This makes the grappler suitable for use with BlacklistingGrappler . Usage: grappler = EntryPointGrappler () Source code in grappler/grapplers/_entry_point.py 52 53 def __init__ ( self ) -> None : self . _groups = metadata . entry_points ()","title":"EntryPointGrappler"},{"location":"api/grapplers/#grappler.grapplers.BouncerGrappler","text":"Bases: PluginPairGrapplerBase [None] Restrict plugins from an inner grappler based on rules defined as predicates. Source code in grappler/grapplers/_bouncer.py 85 86 87 def __init__ ( self , inner : Optional [ Grappler ] = None ) -> None : self . wrapped = inner self . _checks = Checks ( find = [], load = [])","title":"BouncerGrappler"},{"location":"api/grapplers/#grappler.grapplers._bouncer.BouncerGrappler.Mode","text":"Bases: Enum Operating mode for checker functions.","title":"Mode"},{"location":"api/grapplers/#grappler.grapplers._bouncer.BouncerGrappler.Mode.FIND","text":"For checker functions that should only be used during the grappler's scan operation. A plugin that is blocked during this operation will never be seen by grappler's client.","title":"FIND"},{"location":"api/grapplers/#grappler.grapplers._bouncer.BouncerGrappler.Mode.LOAD","text":"For checker functions that should only be used during the grappler's load operation. If a plugin is blocked during this operation, an exception will be raised when attempting to load it.","title":"LOAD"},{"location":"api/grapplers/#grappler.grapplers._bouncer.BouncerGrappler.checker","text":"Register a checker function for the bouncer. This function can be used as a decorator, or called directly: bouncer = BouncerGrappler ( ... ) @bouncer . checker def check_plugin ( plugin : Plugin ) -> bool ... @bouncer . checker ( mode = bouncer . Mode . LOAD ) def check_before_loading_only ( plugin : Plugin ) -> bool ... def check_during_find_only ( plugin : Plugin ) -> bool : ... bouncer . checker ( check_during_find_only , mode = bouncer . Mode . FIND ) Source code in grappler/grapplers/_bouncer.py 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 def checker ( self , checker : Optional [ F_Checker ] = None , * , mode : Mode = Mode . BOTH ) -> Union [ F_Checker , Callable [[ F_Checker ], F_Checker ]]: \"\"\"Register a checker function for the bouncer. This function can be used as a decorator, or called directly: ```python bouncer = BouncerGrappler(...) @bouncer.checker def check_plugin(plugin: Plugin) -> bool ... @bouncer.checker(mode=bouncer.Mode.LOAD) def check_before_loading_only(plugin: Plugin) -> bool ... def check_during_find_only(plugin: Plugin) -> bool: ... bouncer.checker(check_during_find_only, mode=bouncer.Mode.FIND) ``` \"\"\" def decorate ( f : F_Checker ) -> F_Checker : if mode in ( self . Mode . FIND , self . Mode . BOTH ): self . _checks [ \"find\" ] . append ( f ) elif mode in ( self . Mode . LOAD , self . Mode . BOTH ): self . _checks [ \"load\" ] . append ( f ) else : raise ValueError ( f \"Invalid check mode: { mode } \" ) return f if checker is not None : return decorate ( checker ) else : return decorate","title":"checker()"},{"location":"api/grapplers/#grappler.grapplers.CompositeGrappler","text":"Bases: BasicGrappler [ CompositeGrapplerIterationConfig ] Combine plugins and behaviors from multiple grapplers. The types of grappler you can wrap with this are divided into two categories: sources \u2013 A source grappler that provides plugins. Multiple of these may be provided, in which case the plugins will be chained in the order the grapplers were supplied in. These are provided to source() wrappers \u2013 A special grappler that can act as a middleware, adding special behavior. Every grappler in the grappler.grapplers module which wraps a single grappler (e.g. BouncerGrappler ) may be used as a wrapper. If there is more than one wrapper, then they are executed in the order which they were provided in. They are provided to wrap() Source code in grappler/grapplers/_composite.py 94 95 96 97 def __init__ ( self , * sources : Grappler ) -> None : self . _sources = list ( sources ) self . _wrappers : List [ _WrappingGrappler ] = [] self . _groups : Dict [ str , List [ Grappler ]] = {}","title":"CompositeGrappler"},{"location":"api/grapplers/#grappler.grapplers._composite.CompositeGrappler.source","text":"Add a source to the CompositeGrappler . See configure_group() for the meaning of group . Source code in grappler/grapplers/_composite.py 99 100 101 102 103 104 105 106 107 108 109 110 111 112 def source ( self , source : Grappler , / , * , group : Optional [ str ] = None ) -> \"CompositeGrappler\" : \"\"\"Add a source to the `CompositeGrappler`. See [`configure_group()`][grappler.grapplers.CompositeGrappler.configure_group] for the meaning of `group`. \"\"\" self . _sources . append ( source ) if group : self . _groups . setdefault ( group , []) . append ( source ) return self","title":"source()"},{"location":"api/grapplers/#grappler.grapplers._composite.CompositeGrappler.wrap","text":"Add a wrapper to the CompositeGrappler . The grappler will be used to wrap a virtual grappler that is created from all the sources. If more than one wrapper is used, then they will be chained in the order provided. See configure_group() for the meaning of group . Source code in grappler/grapplers/_composite.py 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 def wrap ( self , wrapper : _WrappingGrappler , / , * , group : Optional [ str ] = None ) -> \"CompositeGrappler\" : \"\"\"Add a wrapper to the `CompositeGrappler`. The grappler will be used to wrap a virtual grappler that is created from all the sources. If more than one wrapper is used, then they will be chained in the order provided. See [`configure_group()`][grappler.grapplers.CompositeGrappler.configure_group] for the meaning of `group`. \"\"\" self . _wrappers . append ( wrapper ) if group : self . _groups . setdefault ( group , []) . append ( wrapper ) return self","title":"wrap()"},{"location":"api/grapplers/#grappler.grapplers._composite.CompositeGrappler.configure","text":"Call configuration functions on matching internal grapplers. Grapplers are matched based on the host class of the configuration method passed as target . For example, is target=BouncerGrappler.checker is given, then .checker (...) will be called on every BouncerGrappler instance kept internally, with the given arguments. This method is applied immediately, and matched against the currently registered grapplers. Beware, the type definition for target is not fully correct. When using with a type checker, it is possible that this will allow values that will be rejected at runtime; please test thoroughly. Source code in grappler/grapplers/_composite.py 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 def configure ( self , target : Callable [ Concatenate [ Any , P_Configure ], Any ], * args : P_Configure . args , ** kwargs : P_Configure . kwargs , ) -> \"CompositeGrappler\" : \"\"\" Call configuration functions on matching internal grapplers. Grapplers are matched based on the host class of the configuration method passed as `target`. For example, is `target=BouncerGrappler.checker` is given, then `.checker(...)` will be called on every `BouncerGrappler` instance kept internally, with the given arguments. This method is applied immediately, and matched against the currently registered grapplers. Beware, the type definition for `target` is not fully correct. When using with a type checker, it is possible that this will allow values that will be rejected at runtime; please test thoroughly. \"\"\" return self . _configure ( None , target , * args , ** kwargs )","title":"configure()"},{"location":"api/grapplers/#grappler.grapplers._composite.CompositeGrappler.configure_group","text":"A version of configure() for use with named groups. It will further narrow the matched grapplers to only those is the named group. Named groups are created by passing the group parameter to source() or wrap() . This allows to configure only grapplers with a matching group name. Source code in grappler/grapplers/_composite.py 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 def configure_group ( self , group : str , target : Callable [ Concatenate [ Any , P_Configure ], Any ], / , * args : P_Configure . args , ** kwargs : P_Configure . kwargs , ) -> \"CompositeGrappler\" : \"\"\" A version of [`configure()`][grappler.grapplers.CompositeGrappler.configure] for use with named groups. It will further narrow the matched grapplers to only those is the named group. Named groups are created by passing the `group` parameter to `source()` or `wrap()`. This allows to configure only grapplers with a matching group name. \"\"\" return self . _configure ( group , target , * args , ** kwargs )","title":"configure_group()"},{"location":"api/grapplers/#grappler.grapplers.BlacklistingGrappler","text":"Bases: BouncerGrappler , _ListGrapplerMixin A grappler which allows to blacklist plugins or packages. Blacklisted plugins will be blocked from iteration and loading. When a package is blacklisted, all plugins from it will be blocked. Source code in grappler/grapplers/_list.py 187 188 189 190 191 192 193 194 195 196 def __init__ ( self , inner : Optional [ Grappler ] = None , items : Collection [ Union [ Plugin , Package ]] = (), ) -> None : BouncerGrappler . __init__ ( self , inner ) _ListGrapplerMixin . __init__ ( self , items ) # Install BouncerGrappler.checker to reject listed plugins self . checker ( self . _is_not_listed )","title":"BlacklistingGrappler"},{"location":"api/grapplers/#grappler.grapplers._list.BlacklistingGrappler.blacklist","text":"Add an item to the blacklist. The grappler will skip any plugins that matches a blacklisted item, ensuring that they will not be loaded. This is an instance method with the following signatures: grappler . blacklist ( plugin_or_package : Union [ Plugin , Package ]) -> None : ... @grappler . blacklist def get_blacklisted_plugins () -> List [ Union [ Plugin , Package ]]: return [ ... ] These forms will blacklist plugins or entire packages by their ids . This means that no attempts will be made to match names or any other fields on the plugin on package before blocking it.","title":"blacklist"},{"location":"api/grapplers/#grappler.grapplers._list.BlacklistingGrappler.blacklist--structural-matching","text":"There are two additional signatures which perform a somewhat more structural matching (and therefore blacklisting) of plugins and packages using dictionary specifications: grappler . blacklist ({ \"name\" : \"a-plugin-name\" , \"topics\" : [ \"pytest11\" ]}, type = \"plugin\" ) grappler . blacklist ({ \"platform\" : [ \"win32\" , \"mac\" ]}, type = \"package\" ) In this form, a dictionary spec is given for matching, as well as the type argument. type must be passed as a keyword and must be either \"plugin\" or \"package\" , indicating what kind of specification is being passed in. A type of structural matching is performed on the item, in order to determine if each encountered plugin/package should be blacklisted. Every field in the dictionary is checked as an attribute of either the plugin or package , and a match is determined based on these rules: If the attribute is not present on the plugin/package, there is no match. If the field in the specification is a python collection: if the attribute is also a collection, then it matches only when the attribute is a superset of the specified collection. e.g. the \"topics\" field of the plugin specification above can match plugins which have plugin.topics == (\"pytest11\",) or plugin.topics == (\"foo\", \"pytest11\", \"bar\") etc. if the attribute is not a collection, then it matches only when the attribute is contained within e.g. the package specification above will blacklist only packages that either have package.platform == 'win32' or package.platform == 'mac' . In all other cases, a match only occurs when the attribute is equal to the field specification. All fields in the specification must match a plugin/package for it to be blacklisted.","title":"Structural matching"},{"location":"api/grapplers/#grappler.grapplers.WhitelistingGrappler","text":"Bases: BouncerGrappler , _ListGrapplerMixin A grappler which allows to whitelist plugins or packages Source code in grappler/grapplers/_list.py 278 279 280 281 282 283 284 285 286 287 def __init__ ( self , inner : Optional [ Grappler ] = None , items : Collection [ Union [ Plugin , Package ]] = (), ) -> None : BouncerGrappler . __init__ ( self , inner ) _ListGrapplerMixin . __init__ ( self , items ) # Install BouncerGrappler.checker to reject non listed plugins self . checker ( self . _is_listed )","title":"WhitelistingGrappler"},{"location":"api/grapplers/#grappler.grapplers._list.WhitelistingGrappler.whitelist","text":"Add an item to the whitelist. The grappler will skip all items unless they are in the whitelist. This function has the same signature as BlacklistingGrappler.blacklist()","title":"whitelist"}]}